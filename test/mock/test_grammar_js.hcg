@NAME JavaScriptParser

@EXT js

@SYMBOL  ... < > <= >= == != === !== ** ++ -- << >> >>> && || += -= *= %= /= **= <<= >>= >>>= &= |= ^= => // /* ${ ?. ??

@IGNORE θws θnl

@ERROR /* //

@IMPORT default-productions as def 

###############################################################################################################
#### Repeated Functions
###############################################################################################################

↦BindingExpression{ { type:"BindingExpression", symbol:"=", nodes: [$sym1, $sym2],  pos  } }

↦Spread{ { type:"Spread", nodes: [$sym2],  pos  } }


###############################################################################################################
###############################################################################################################
###############################################################################################################
# Productions
###############################################################################################################
###############################################################################################################
###############################################################################################################

<> javascript → start                                                                                           ↦r { env.IS_MODULE = false, $sym1 }

<> start → module                                                                                               ↦r { { type:(env.IS_MODULE) ? "Module" : "Script", nodes:$sym1, pos  } }

###############################################################################################################
###############################################################################################################
## MODULES
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

    <> module → module_body      

    <> module_body → module_item(+)                                                                         

    <> module_item → import_declaration                                                                         ↦ { env.IS_MODULE = true }
        │ export_declaration                                                                                    ↦ { env.IS_MODULE = true }
        │ statement_list_item

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-ImportDeclaration
###############################################################################################################

    <> import_declaration → τimport import_clause from_clause ;                                                 ↦r { { type:"ImportDeclaration", nodes:[$sym2, $sym3], pos } }
        │ τimport module_specifier ;                                                                            ↦r { { type:"ImportDeclaration", nodes:[null, $sym2], pos } }

    <> import_clause → imported_default_binding                                                                 ↦r { { type:"ImportClause", nodes:[$$sym1], pos } }
        │ name_space_import                                                                                     ↦r { { type:"ImportClause", nodes:[$$sym1], pos } }
        │ named_imports                                                                                         ↦r { { type:"ImportClause", nodes:[$$sym1], pos } }
        │ imported_default_binding , name_space_import                                                          ↦r { { type:"ImportClause", nodes:[$$sym1, $$sym3], pos } }
        │ imported_default_binding , named_imports                                                              ↦r { { type:"ImportClause", nodes:[$$sym1, $$sym3], pos } }

    <> imported_default_binding → imported_binding                                                              ↦r { $sym1.type = "IdentifierDefault", $sym1 }

    <> name_space_import → * τas imported_binding                                                               ↦r { { type:"NameSpaceImport", nodes:[$$sym3], pos } }

    <> named_imports → { import_specifier(*,) ,? }                                                              ↦r { { type:"NamedImports", nodes:$$sym2 || [], pos } }

    <> from_clause → τfrom module_specifier                                                                     ↦r { { type:"FromClause", nodes:[$sym2], pos } }

    <> import_specifier → imported_binding                                                                      ↦r { { type:"Specifier", nodes:[$sym1], pos } }
        │ identifier τas imported_binding                                                                       ↦r { { type:"Specifier", nodes:[$sym1, $sym3], pos } }

    <> module_specifier → string_literal                                                                        

    <> imported_binding → identifier                                                                            ↦r { $sym1.type = "IdentifierModule", $sym1 }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-exports
###############################################################################################################

    <> export_declaration → τexport * from_clause ;                                                             ↦r { { type:"ExportDeclaration", nodes:[null, $sym3], DEFAULT:false, pos } }
        │ τexport export_clause from_clause? ;                                                                  ↦r { { type:"ExportDeclaration", nodes:[$sym2, $$sym3], DEFAULT:false, pos } }
        │ τexport variable_statement                                                                            ↦r { { type:"ExportDeclaration", nodes:[$sym2], DEFAULT:false, pos } }
        │ τexport declaration                                                                                   ↦r { { type:"ExportDeclaration", nodes:[$sym2], DEFAULT:false, pos } }
        │ τexport τdefault hoistable_declaration                                                                ↦r { { type:"ExportDeclaration", nodes:[$sym3], DEFAULT:true, pos } }
        │ τexport τdefault class_declaration                                                                    ↦r { { type:"ExportDeclaration", nodes:[$sym3], DEFAULT:true, pos } }
        │ τexport τdefault                                                                                      

            (EXC τfunction )
            (EXC τclass )
            (EXC τasync τfunction )
        
            assignment_expression ;                                                                              ↦r { { type:"ExportDeclaration", nodes:[$sym3], DEFAULT:true, pos } }

    <> export_clause → { export_specifier(*,) ,? }                                                              ↦r { { type:"ExportClause", nodes:$$sym2||[], pos } }

    <> export_specifier →  identifier                                                                           ↦r { { type:"Specifier", nodes:[$sym1], pos } }
        │ identifier τas identifier                                                                             ↦r { { type:"Specifier", nodes:[$sym1, $sym3], pos } }

###############################################################################################################
###############################################################################################################
## SCRIPT
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

    <> script → script_body                                                                                     ↦r { { type:"Script", nodes:$sym1, pos } }

    <> script_body → statement_list                                                                            

############################################################################################################### 
###############################################################################################################
## STATEMENTS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Statement
###############################################################################################################

    <> statement_list → statement_list_item                                                                     ↦r { [ $sym1 ] }
        │ statement_list statement_list_item                                                                    ↦r { [ ...$sym1, $sym2 ] }                             

    <> statement_list_item → statement 
        │ declaration


    <> statement → block_statement 
        │ 
            (EXC { )
            (EXC τfunction )
            (EXC τclass )
            (EXC τlet \[ )
            (EXC τasync τfunction )

            expression_statement                           

        │ labeled_statement
        │ variable_statement
        │ empty_statement
        │ if_statement
        │ breakable_statement 
        │ continue_statement
        │ break_statement
        │ return_statement
        │ with_statement
        │ throw_statement
        │ try_statement
        │ debugger_statement

    <> declaration → class_declaration
        │ hoistable_declaration
        │ lexical_declaration

    <> hoistable_declaration → function_declaration
        #│ generator_declaration
        #│ async_function_declaration
        #│ async_generator_declaration

    <> breakable_statement → iteration_statement
        │ switch_statement


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-block
###############################################################################################################

    <> block_statement → block                          

    <> block → { statement_list? }                                                                               ↦r { { type: "BlockStatement", nodes: $$sym2 || [], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-empty-statement
###############################################################################################################

    <> empty_statement → ;                                                                                      ↦r { { type: "EmptyStatement", pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-expression-statement
###############################################################################################################

    <> expression_statement → expression ;                                                                      ↦r { { type: "ExpressionStatement", nodes:[$sym1], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-expression-statement
###############################################################################################################

    <> if_statement → τif \( expression \) statement (τelse statement)?                                         ↦r { { type: "IfStatement", nodes:[$$sym3, $$sym5, $$sym6], pos } }                

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-iteration-statements
###############################################################################################################

    <> iteration_statement → τdo statement τwhile \( expression \) ;                                            ↦r { { type: "DoStatement", nodes:[$$sym2, $$sym5], pos } }

        │ τwhile \( expression \) statement                                                                     ↦r { { type: "WhileStatement", nodes:[$$sym3, $$sym5], pos } }
        
        │ τfor \( ↦{ env.ASI = false; } (
            (EXC τlet \[ ) expression 
            │ τvar variable_declaration_list ↦r { { type:"VariableDeclaration", nodes:$sym2, pos } }
            )? ; expression? ; expression? \) ↦{ env.ASI = true;} statement                                                 
                                                                                                                ↦r { { type: "ForStatement", nodes:[$$sym3, $$sym5, $$sym7, $$sym9], LEX:false, pos } }

        │ τfor \( lexical_declaration expression? ; expression? \)↦{ env.ASI = true;} statement                 ↦r { { type: "ForStatement", nodes:[$$sym3, $$sym4, $$sym6, $$sym8], LEX:true, pos } }                                                                           
                                                                                                                                                                                                                                                                            
        │ τfor \( (
                (EXC τlet \[ ) left_hand_side_expression
                │ τvar for_binding ↦r { { type:"VariableDeclaration", nodes:[$sym1], pos }  }
                │ for_declaration
            ) τin expression \)↦{ env.ASI = true;} statement                                                    ↦r { { type: "ForInStatement", nodes:[$$sym3, $$sym5, $$sym7], pos } } 

        │ τfor τawait? \( (
                (EXC τlet \[ ) left_hand_side_expression
                │ τvar for_binding ↦r { { type:"VariableDeclaration", nodes:[$sym1],lex }  }
                │ for_declaration
            ) τof expression \)↦{ env.ASI = true;} statement                                                    ↦r { { type: "ForOfStatement", nodes:[$$sym4, $$sym6, $$sym8], pos, AWAIT:!!$$sym2 } }

    <> for_declaration → let_or_const for_binding                                                               ↦r { { type: "LexicalBinding", nodes:[$$sym2], symbol:$$sym1, pos } }

    <> for_binding → binding_identifier 
        │ binding_pattern 

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-continue-statement
###############################################################################################################

    <> continue_statement → τcontinue (RED θnl) label_identifier? ;                                             ↦r { { type: "ContinueStatement", nodes:$$sym2 ? [$$sym2] : [], pos } }  

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-break-statement
###############################################################################################################

    <> break_statement → τbreak label_identifier? ;                                                             ↦r { { type: "BreakStatement", nodes:[$$sym2], pos } }


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-return-statement
###############################################################################################################

    <> return_statement → τreturn expression? ;                                                                 ↦r { { type:"ReturnStatement", nodes:[$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-throw-statement
###############################################################################################################

    <> throw_statement → τthrow expression ;                                                                    ↦r { { type:"ThrowStatement", nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-with-statement
###############################################################################################################

    <> with_statement → τwith \( expression \) statement                                                        ↦r { { type:"WithStatement", nodes:[$$sym3, $$sym5], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-switch-statement
###############################################################################################################

    <> switch_statement → τswitch \( expression \) case_block                                                   ↦r { { type:"SwitchStatement", nodes:[$$sym3, $$sym5], pos } }

    <> case_block → { case_clauses? default_clause? case_clauses? }                                             ↦r { { type:"CaseBlock", nodes:[...$sym2, $sym3, ...$sym4], pos } }

    <> case_clauses → case_clause(+)

    <> case_clause → τcase expression : statement_list?                                                         ↦r { { type:"CaseClause", nodes:[$$sym2, ...$sym4], pos } }

    <> default_clause → τdefault : statement_list?                                                              ↦r { { type:"DefaultClause", nodes:[...$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-labeled-statements
###############################################################################################################

    <> labeled_statement → label_identifier : labeled_item                                                    ↦r { { type:"LabeledStatement", nodes:[$$sym1, $$sym3], pos } }

    <> labeled_item → statement
        │ function_declaration

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-try-statement
###############################################################################################################

    <> try_statement → τtry block catch                                                                         ↦r { { type:"TryStatement", nodes:[$$sym2,$$sym3,null], pos } }
        │ τtry block finally                                                                                    ↦r { { type:"TryStatement", nodes:[$$sym2,null,$$sym3], pos } }
        │ τtry block catch  finally                                                                             ↦r { { type:"TryStatement", nodes:[$$sym2,$$sym3,$$sym4], pos } }

    <> catch → τcatch \( catch_parameter \) block                                                               ↦r { { type:"CatchClause", nodes:[$$sym3, $$sym5], pos } }

    <> finally → τfinally block                                                                                 ↦r { { type:"FinallyClause", nodes:[$$sym2], pos } }

    <> catch_parameter → binding_identifier 
        │ binding_pattern

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-debugger-statement
###############################################################################################################

    <> debugger_statement → τdebugger ;                                                                         ↦r { { type:"DebuggerStatement", pos } }

###############################################################################################################
###############################################################################################################
## DECLARATIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-variable-statement
###############################################################################################################

    <> variable_statement → τvar variable_declaration_list ;                                                    ↦r { { type:"VariableStatement", nodes:$sym2, pos } }

    <> variable_declaration_list → variable_declaration(+,)                                                         

    <> variable_declaration → binding_identifier initializer                                                    ↦r=>BindingExpression
        │ binding_identifier                                        
        │ binding_pattern initializer                                                                           ↦r=>BindingExpression


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-let-and-const-declarations
###############################################################################################################

        <> lexical_declaration → let_or_const binding_list ;                                                    ↦r { { type:"LexicalDeclaration", symbol:$sym1, nodes:$sym2, pos } }

        <> let_or_const → τlet                                                                                  ↦r { "let" }
            │ τconst                                                                                            ↦r { "const" }

        <> binding_list → lexical_binding(+,)                                                                            

        <> lexical_binding → binding_identifier
            │ binding_identifier initializer                                                                    ↦r=>BindingExpression
            │ binding_pattern initializer                                                                       ↦r=>BindingExpression

###############################################################################################################
###############################################################################################################
## FUNCTIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-function-definitions
###############################################################################################################

    ## Modified to include async and function generator elements

    <> function_declaration →  τasync? τfunction \*? binding_identifier? 
                                \( formal_parameters? \) { function_body? }                                     ↦r { { type:"FunctionDeclaration", ASYNC:!!$$sym1, GENERATOR:!!$$sym3, nodes:[$$sym4,$$sym6,$$sym9], pos } }

    <> function_expression → τasync? τfunction \*? binding_identifier? 
                                \( formal_parameters? \) { function_body? }                                     ↦r { { type:"FunctionExpression", ASYNC:!!$$sym1, GENERATOR:!!$$sym3, nodes:[$$sym4,$$sym6,$$sym9], pos } }

    <> unique_formal_parameters → formal_parameters

    <> formal_parameters → function_rest_parameter                                                              ↦r { { type:"FormalParameters", nodes:[$sym1], pos } }
         │ formal_parameter_list ,?                                                                             ↦r { { type:"FormalParameters", nodes:$sym1, pos } }
         │ formal_parameter_list , function_rest_parameter                                                      ↦r { { type:"FormalParameters", nodes:[...$sym1,$$sym3], pos } }

    <> formal_parameter_list → formal_parameter(+,)                                                                     

    <> function_rest_parameter → binding_rest_element           

    <> formal_parameter → binding_element

    <> function_body → function_statement_list                                                                  ↦r { { type:"FunctionBody", nodes:$sym1, pos } }

    <> function_statement_list → statement_list?

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-GeneratorExpression
###############################################################################################################

    # <> async_function_declaration → τasync τfunction binding_identifier? \( formal_parameters? \) { async_function_body? }     

    # <> async_function_expression → τasync τfunction \( formal_parameters? \) { async_function_body? }                          

    # <> async_function_method → τasync property_name \( unique_formal_parameters? \) { async_function_body? }                   

    # <> async_function_body → function_body

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-AsyncGeneratorExpression
###############################################################################################################

    # <> async_generator_method → τasync \* property_name \( unique_formal_parameters? \) { async_generator_body? }               

    # <> async_generator_declaration → τasync τfunction \* binding_identifier? \( formal_parameters? \) { async_function_body? }  

    # <> async_generator_expression → τasync τfunction \* \( formal_parameters? \) { async_function_body? }                       

    # <> async_generator_body → function_body

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-GeneratorExpression
###############################################################################################################

    # <> generator_method → \* property_name  \( unique_formal_parameters? \) { generator_body }                                  

    # <> generator_declaration → τfunction \* binding_identifier \( formal_parameters? \) { generator_body }                       

    # <> generator_expression → τfunction \* \( formal_parameters? \) {generator_body}                                             

    # <> generator_body → function_body

    <> yield_expression → τyield θnl                                                                   ↦r { { type: "YieldExpression", nodes:[], pos } }
        │ τyield (\*)? assignment_expression                                                             ↦r { { type: "YieldExpression", nodes:[$$sym3], pos, GENERATOR:!!$$sym2 } }


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-arrow-function-definitions
###############################################################################################################

    <> arrow_function → τasync? arrow_parameters => concise_body                                                ↦r { { type:"ArrowFunction", ASYNC:!!$$sym1, nodes:[$$sym2,$$sym4], pos } }

    <> arrow_parameters → identifier_reference                                                                  ↦r { $sym1.type = "IdentifierBinding", $sym1 }    
        │ cover_parenthesized_expression_and_arrow_parameter_list                                               ↦r ^reinterpretArrowParameters

    <> concise_body → (EXC { ) assignment_expression 
        │ { function_statement_list }                                                                           ↦r { { type: "BlockStatement", nodes: $sym2, pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-async-arrow-function-definitions
###############################################################################################################

    #    <> async_arrow_function → τasync async_arrow_parameters => async_concise_body                          ↦c ^async_arrow

    #    <> async_arrow_parameters → binding_identifier 
    #        │ cover_call_expression_and_async_arrow_head                                                       

    #    <> async_concise_body → (EXC { ) assignment_expression 
    #        │ { function_statement_list }                                                                      ↦r { $sym2 }

    <> cover_call_expression_and_async_arrow_head → member_expression arguments                                 ↦r { { type: "CallExpression", nodes:[$sym1, $sym2], pos } }

###############################################################################################################
###############################################################################################################
## CLASSES
############################################################################################################### 
###############################################################################################################

###############################################################################################################
# https://www.ecma-international.org/ecma-262/index.html#sec-class-definitions
###############################################################################################################

    <> class_declaration → τclass binding_identifier? class_heritage? { class_body? }                           ↦r { { type:"Class", nodes:[$$sym2, $$sym3, ...$sym5], pos } }

    <> class_expression → τclass binding_identifier? class_heritage? { class_body? }                            ↦r { { type:"Class", nodes:[$$sym2, $$sym3, ...$sym5], pos } }

    <> class_heritage → τextends left_hand_side_expression                          

    <> class_body → class_element                                                                               ↦r { [$sym1 ] } 
        | class_body class_element                                                                              ↦r { $sym1.concat($sym2) } 
        | class_body ;                                                                                          ↦r { $sym1 }
        | ;                                                                                                     ↦r { [] }

    <> class_element → method_definition 
        │ τstatic method_definition                                                                             ↦r { ( $sym2.STATIC = true, $sym2) }
        

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-MethodDefinition
###############################################################################################################

    <> method_definition → τasync? \*? property_name \( unique_formal_parameters? \) { function_body? }         ↦r { { type:"Method", ASYNC:!!$$sym1, GENERATOR:!!$$sym2, nodes:[$$sym3, $$sym5, $$sym8], pos } } 
        │ τget property_name \( \) { function_body? }                                                           ↦r { { type:"GetterMethod", nodes:[$$sym2, $sym6], pos } }
        │ τset property_name \( property_set_parameter_list \) { function_body? }                               ↦r { { type:"SetterMethod", nodes:[$$sym2, $$sym4, $sym7], pos } }

    <> property_set_parameter_list → formal_parameter 

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-comma-operator
###############################################################################################################

    <> expression → expression , assignment_expression                                                          ↦r { ( $sym1.type == "ExpressionList" ? ( $sym1.nodes.push($sym3) , $sym1 )
                                                                                                                : { type: "ExpressionList", nodes: [$sym1, $sym3], pos } ) }
        │ assignment_expression                                                                                 
                    
###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-left-hand-side-expressions
###############################################################################################################

    <> left_hand_side_expression → new_expression       
        │ call_expression         
        | optional_expression                      

    <> new_expression → member_expression 
        │ τnew new_expression                                                                                   ↦r { { type: "NewExpression", nodes:[$$sym2], pos } }

    <> member_expression → primary_expression                   
        │ member_expression \[ expression \]                                                                    ↦r { { type: "MemberExpression", nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        │ member_expression . identifier_name                                                                   ↦r { ($sym3.type |= env.cls.PROPERTY_NAME, { type: "MemberExpression", nodes:[$$sym1, $$sym3], pos, COMPUTED:false }) }
        │ member_expression template_literal                                                                    ↦r { { type: "CallExpression", nodes:[$$sym1, $$sym2], pos, TEMPLATE:true } }
        │ super_property
        │ meta_property
        │ τnew member_expression arguments                                                                      ↦r { { type: "NewInstanceExpression", nodes:[$$sym2, $$sym3], pos } }

    <> super_property → τsuper . identifier_name                                                                ↦r { ($sym3.type |= env.cls.PROPERTY_NAME,{ type: "SuperExpression", nodes:[$$sym3], pos, COMPUTED:false } ) }
        │ τsuper \[ expression \]                                                                               ↦r { { type: "SuperExpression", nodes:[$$sym3], pos, COMPUTED:true } }

    <> meta_property → new_target
        | import_meta
    
    ##
    # 2020 https://www.ecma-international.org/ecma-262/#prod-ImportMeta
    ##
    <> import_meta > τimport . τmeta                                                                            ↦r { { type: "ImportMeta", pos } }

    <> new_target → τnew . τtarget                                                                              ↦r { { type: "NewTarget", pos } }

    <> call_expression → call_expression . identifier_name                                                      ↦r { ($sym3.type |= env.cls.PROPERTY_NAME,{ type: "MemberExpression", nodes:[$$sym1, $$sym3], pos, COMPUTED:false } )}
        │ super_call
        │ import_call
        │ call_expression arguments                                                                             ↦r { { type: "CallExpression", nodes:[$$sym1, $$sym2], pos, TEMPLATE:false } }
        │ call_expression \[ expression \]                                                                      ↦r { { type: "MemberExpression", nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        │ cover_call_expression_and_async_arrow_head                                                            
        │ call_expression template_literal                                                                      ↦r { { type: "CallExpression", nodes:[$$sym1, $$sym3], pos, TEMPLATE:true } }

    <> super_call → τsuper arguments                                                                            ↦r { { type: "SuperCall", nodes:[$$sym2], pos } }
    
    ##
    # 2020 https://www.ecma-international.org/ecma-262/#prod-ImportCall
    ##
    <> import_call → τimport \( assignment_expression \)                                                         ↦r { { type: "ImportCall", nodes:[$$sym3], pos } }

    <> arguments →  \( argument_list? ,? \)                                                                      ↦r { { type: "Arguments", nodes:$$sym2 || [], pos } }

    <> argument_list → (assignment_expression │ ... assignment_expression ↦r=>Spread  )(+,)

###############################################################################################################
# 2020 https://www.ecma-international.org/ecma-262/#prod-OptionalExpression
###############################################################################################################
                               
    <> optional_expression > member_expression optional_chain                                                   ↦r { { type: "OptionalMemberExpression", nodes:[$$sym1, $$sym2], pos, COMPUTED:false } }
        │ call_expression optional_chain                                                                        ↦r { { type: "OptionalMemberExpression", nodes:[$$sym1, $$sym2], pos, COMPUTED:false } }
        │ optional_expression optional_chain                                                                    ↦r { { type: "OptionalMemberExpression", nodes:[$$sym1, $$sym2], pos, COMPUTED:false } }

    <> optional_chain > \?. arguments                                                                           #↦r { { type: "OptionalChain", nodes:[$$sym2], pos } }
        | \?. [ expression ]                                                                                    #↦r { { type: "OptionalChain", nodes:[$$sym2], pos } }
        | \?. identifier_name                                                                                   #↦r { { type: "OptionalChain", nodes:[$$sym2], pos } }
        | \?. template_literal                                                                                  #↦r { { type: "OptionalChain", nodes:[$$sym2], pos } }
        | optional_chain arguments                                                                              ↦r { { type: "CallExpression", nodes:[$$sym1, $$sym2], pos, TEMPLATE:false } }
        | optional_chain [ expression ]                                                                         ↦r { { type: "MemberExpression", nodes:[$$sym1, $$sym3], pos, COMPUTED:true } }
        | optional_chain \. identifier_name                                                                     ↦r { ($sym3.type |= env.cls.PROPERTY_NAME, { type: "MemberExpression", nodes:[$$sym1, $$sym3], pos, COMPUTED:false }) }
        | optional_chain template_literal                                                                       ↦r { { type: "CallExpression", nodes:[$$sym1, $$sym2], pos, TEMPLATE:true } }
        



###############################################################################################################
#https://www.ecma-international.org/ecma-262/10.0/index.html#sec-primary-expression
###############################################################################################################

    <> primary_expression → τthis                                                                               ↦r { { type: "ThisLiteral", pos } }
        │ identifier_reference
        │ literal
        │ array_literal                                             
        │ object_literal                                            
        │ function_expression
        │ class_expression
        │ regular_expression_literal
        │ template_literal
        │ parenthesized                                                                                         ↦r ^reinterpretParenthesized

        #│ generator_expression
        #│ async_function_expression
        #│ async_generator_expression

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-AwaitExpression
###############################################################################################################

    <> await_expression → τawait unary_expression                                                               ↦r { { type: "AwaitExpression", nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-BindingExpression
###############################################################################################################

    <> assignment_expression → conditional_expression 
        │ yield_expression
        │ arrow_function
        │ left_hand_side_expression = assignment_expression                                                     ↦r { { type: "AssignmentExpression", symbol:"=",  nodes:[$sym1,$sym3], pos } }
        │ left_hand_side_expression assignment_operator assignment_expression                                   ↦r { { type: "AssignmentExpression", symbol:$sym2,  nodes:[$sym1,$sym3], pos } }
        
        #│ async_arrow_function

    <> assignment_operator → *=                                                        
        │ /=                                                                        
        │ %=                                                                        
        │ +=                                                                        
        │ -=                                                                        
        │ <<=                                                                       
        │ >>=                                                                       
        │ >>>=                                                                      
        │ &=                                                                        
        │ ^=                                                                        
        │ |=                                                                        
        │ **=                                                                       

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-ConditionalExpression
###############################################################################################################

    <> conditional_expression → short_circuit_expression
        │ short_circuit_expression \? assignment_expression : assignment_expression                            ↦r { { type: "ConditionalExpression", nodes:[$$sym1, $$sym3, $$sym5], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-binary-logical-operators
###############################################################################################################
    
    <> short_circuit_expression → logical_or_expression
        │ coalesce_expression
    

    <> logical_or_expression → logical_and_expression 
        │ logical_or_expression \|| logical_and_expression                                                      ↦r { { type: "LogicalExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> logical_and_expression → bitwise_or_expression 
        │ logical_and_expression && bitwise_or_expression                                                       ↦r { { type: "LogicalExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    ##
    # 2020 https://www.ecma-international.org/ecma-262/#prod-CoalesceExpression
    ##

    <> coalesce_expression →  coalesce_expression_head \?? bitwise_or_expression                                ↦r { { type: "CoalesceExpression", nodes:[$$sym1, $$sym3], pos } }

    <> coalesce_expression_head > ( coalesce_expression │ bitwise_or_expression  )          




###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-binary-bitwise-operators
###############################################################################################################

    <> bitwise_or_expression → bitwise_xor_expression 
        │ bitwise_or_expression \| bitwise_xor_expression                                                        ↦r { { type: "BitwiseExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> bitwise_xor_expression → bitwise_and_expression 
        │ bitwise_xor_expression ^ bitwise_and_expression                                                       ↦r { { type: "BitwiseExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> bitwise_and_expression → equality_expression 
        │ bitwise_and_expression & equality_expression                                                          ↦r { { type: "BitwiseExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

    <> equality_expression → relational_expression 
        │ equality_expression == relational_expression                                                          ↦r { { type: "EqualityExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression != relational_expression                                                          ↦r { { type: "EqualityExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression === relational_expression                                                         ↦r { { type: "EqualityExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ equality_expression !== relational_expression                                                         ↦r { { type: "EqualityExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-relational-operators
###############################################################################################################

    <> relational_expression → shift_expression 
        │ relational_expression < shift_expression                                                              ↦r { { type: "RelationalExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression \>  shift_expression                                                            ↦r { { type: "RelationalExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression <= shift_expression                                                             ↦r { { type: "RelationalExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression >= shift_expression                                                             ↦r { { type: "RelationalExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression τinstanceof shift_expression                                                    ↦r { { type: "InstanceOfExpression",  nodes:[$$sym1, $$sym3], pos } }
        │ relational_expression τin shift_expression                                                            ↦r { { type: "InExpression",  nodes:[$$sym1, $$sym3], pos } }   

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-bitwise-shift-operators
###############################################################################################################

    <> shift_expression → additive_expression 
        │ shift_expression << additive_expression                                                               ↦r { { type: "ShiftExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ shift_expression >> additive_expression                                                               ↦r { { type: "ShiftExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ shift_expression >>> additive_expression                                                              ↦r { { type: "ShiftExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-additive-operators
###############################################################################################################

    <> additive_expression → multiplicative_expression 
        │ additive_expression + multiplicative_expression                                                       ↦r { { type: "AdditiveExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ additive_expression - multiplicative_expression                                                       ↦r { { type: "AdditiveExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-multiplicative-operators
###############################################################################################################

    <> multiplicative_expression → exponentiation_expression 
        │ multiplicative_expression * exponentiation_expression                                                 ↦r { { type: "MultiplicativeExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ multiplicative_expression / exponentiation_expression                                                 ↦r { { type: "MultiplicativeExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }
        │ multiplicative_expression % exponentiation_expression                                                 ↦r { { type: "MultiplicativeExpression", symbol:$$sym2, nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-exp-operator
###############################################################################################################

    <> exponentiation_expression → unary_expression 
        │ update_expression ** exponentiation_expression                                                        ↦r { { type: "ExponentiationExpression", nodes:[$$sym1, $$sym3], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-unary-operators
###############################################################################################################

    <> unary_expression → update_expression 
        │ τdelete unary_expression                                                                              ↦r { { type: "DeleteExpression", nodes:[$$sym2], pos } }
        │ τvoid unary_expression                                                                                ↦r { { type: "VoidExpression", nodes:[$$sym2], pos } }
        │ τtypeof unary_expression                                                                              ↦r { { type: "TypeofExpression", nodes:[$$sym2], pos } }
        │ + unary_expression                                                                                    ↦r { { type: "UnaryExpression", symbol:$sym1, nodes:[$$sym2], pos } }
        │ - unary_expression                                                                                    ↦r { { type: "UnaryExpression", symbol:$sym1, nodes:[$$sym2], pos } }
        │ ~ unary_expression                                                                                    ↦r { { type: "UnaryExpression", symbol:$sym1, nodes:[$$sym2], pos } }
        │ ! unary_expression                                                                                    ↦r { { type: "UnaryExpression", symbol:$sym1, nodes:[$$sym2], pos } }
        │ await_expression

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-update-expressions
###############################################################################################################

    <> update_expression →  left_hand_side_expression 
        │ left_hand_side_expression  ++                                                                         ↦r { { type: "PostExpression", symbol:$$sym2, nodes:[$$sym1], pos } }
        │ left_hand_side_expression  --                                                                         ↦r { { type: "PostExpression", symbol:$$sym2, nodes:[$$sym1], pos } }
        │ ++ unary_expression                                                                                   ↦r { { type: "PreExpression", symbol:$$sym1, nodes:[$$sym2], pos } }
        │ -- unary_expression                                                                                   ↦r { { type: "PreExpression", symbol:$$sym1, nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-CoverParenthesizedExpressionAndArrowParameterList
###############################################################################################################

    <> cover_parenthesized_expression_and_arrow_parameter_list → \( \)                                          ↦r { { type: "Parenthesized", nodes:[], pos } }
        │ \( expression , \)                                                                                    ↦r { { type: "Parenthesized", nodes:[$$sym2], pos } }
        │ \( (... binding_identifier ↦r=>Spread)  \)                                                            ↦r { { type: "Parenthesized", nodes:[$$sym2], pos } }
        │ \( (... binding_pattern ↦r=>Spread) \)                                                                ↦r { { type: "Parenthesized", nodes:[$$sym2], pos } }
        │ \( expression , (... binding_identifier ↦r=>Spread)  \)                                               ↦r { { type: "Parenthesized", nodes:[$$sym2, $$sym4], pos } }
        │ \( expression , (... binding_pattern ↦r=>Spread)  \)                                                  ↦r { { type: "Parenthesized", nodes:[$$sym2, $$sym4], pos } }                                                                                       
        │ parenthesized                                                                                         
    
    <> parenthesized → \( expression \)                                                                         ↦r { { type: "Parenthesized", nodes:[$$sym2], pos } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-BindingPattern
###############################################################################################################

    <> binding_pattern → object_binding_pattern
        │   array_binding_pattern

    <> object_binding_pattern → { }                                                                             ↦r { { type: "ObjectBinding", nodes:[], pos } }
        │ { binding_rest_property }                                                                             ↦r { { type: "ObjectBinding", nodes:[$sym2], pos } }
        │ { binding_property_list  }                                                                            ↦r { { type: "ObjectBinding", nodes:[...$sym2], pos } }    
        │ { binding_property_list , binding_rest_property? }                                                    ↦r { { type: "ObjectBinding", nodes:[...$sym2, $sym4], pos } }    

    <> array_binding_pattern → 
        \[ elision? binding_rest_element? \]                                                                    ↦r { { type: "ArrayBinding", nodes:[$sym2, $sym3], pos } }
        # │ \[ elision \]                                                                                         ↦r { { type: "ArrayBinding", nodes:[$sym2], pos } }    
        # │ \[ binding_rest_element \]                                                                            ↦r { { type: "ArrayBinding", nodes:[$sym2], pos } }    
        │ \[ binding_element_list \]                                                                            ↦r { { type: "ArrayBinding", nodes:[...$sym2], pos } }    
        #│ \[ binding_element_list , \]                                                                          ↦r { { type: "ArrayBinding", nodes:[...$sym2], pos } }    
        #│ \[ binding_element_list , elision? \]                                                                 ↦r { { type: "ArrayBinding", nodes:[...$sym2, $sym4], pos } }    
        │ \[ binding_element_list , elision? binding_rest_element? \]                                            ↦r { { type: "ArrayBinding", nodes:[...$sym2, $sym4, $sym5], pos } }    
        #│ \[ binding_element_list , binding_rest_element \]                                                     ↦r { { type: "ArrayBinding", nodes:[...$sym2, $sym4], pos } }    

    <> binding_rest_property → \... binding_identifier                                                           ↦r=>Spread

    <> binding_property_list → binding_property                                                                 ↦r { [$$sym1] }
        | binding_property_list \, binding_property                                                             ↦r { [...$$sym1, $sym3] }
    
    <> binding_element_list → binding_elision_element                                                           
        | binding_element_list \, binding_elision_element                                                       ↦r { [...$$sym1, ...$sym3] }

    <> binding_elision_element → elision? binding_element                                                       ↦r { [$sym1, $sym2] }                                                    

    <> binding_property → single_name_binding 
        │ property_name : binding_element                                                                       ↦r { { type:"PropertyBinding", nodes:[$sym1, $sym3],  pos  } }  

    <> binding_element → single_name_binding
        │ binding_pattern initializer?                                                                           ↦r { $$sym2 ? { type:"BindingExpression", nodes: [$sym1, $sym2],  pos  } : $sym1 }

    <> single_name_binding → binding_identifier initializer?                                                     ↦r { $$sym2 ? { type:"BindingExpression", nodes: [$sym1, $sym2],  pos  } : $sym1 }

    <> binding_rest_element → \... binding_identifier                                                            ↦r=>Spread
        │ \... binding_pattern                                                                                   ↦r=>Spread                                                                                              


###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#prod-RegularExpressionLiteral
###############################################################################################################

    <> regular_expression_literal → ↦^parseRegex \/ \/ def::js_identifier?                                      ↦r { { type:"RegexLiteral", value:$sym1, flags:$sym3,  pos  } }

    <> regular_expression_flags → identifier_name  

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-object-initializer
###############################################################################################################

    <> object_literal →  { }                                                                                    ↦r { { type:"ObjectLiteral", nodes:[],  pos  } }
        │ { property_definition_list ,? }                                                                       ↦r { { type:"ObjectLiteral", nodes:$sym2,  pos  } }

    <> property_definition_list → property_definition                                                           ↦r { [$sym1] }
        │ property_definition_list , property_definition                                                        ↦r { $sym1.push($sym3), $sym1 }       

    <> property_definition →  cover_initialized_name                
        │ identifier_reference                                                                                  ↦r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }
        │ method_definition                                                                                     
        │ ... assignment_expression                                                                             ↦r=>Spread
        │ property_name : assignment_expression                                                                 ↦r { { type:"PropertyBinding", nodes:[$sym1, $sym3],  pos  } }       

    <> property_name → literal_property_name                                                                    ↦r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }
        │ computed_property_name                                                                                ↦r { $sym1.type |= env.cls.PROPERTY_NAME, $sym1 }

    <> literal_property_name → identifier_name                                                                  
        │ string_literal
        │ numeric_literal

    <> computed_property_name → \[ assignment_expression \]                                                     ↦r { { type: "ComputedProperty", nodes:[$sym2], pos } }

    <> cover_initialized_name → identifier_reference initializer                                                ↦{ sym[sym.length-2].type |= env.cls.PROPERTY_NAME } ↦r=>BindingExpression

    <> initializer → = assignment_expression                                                                    ↦r { $sym2 }
    

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-array-initializer
###############################################################################################################

    <> array_literal → \[ elision? \]                                                                           ↦r { { type: "ArrayLiteral", nodes:[$sym2], pos } }
        │ \[ element_list \]                                                                                    ↦r { { type: "ArrayLiteral", nodes:$$sym2, pos } }
        │ \[ element_list , elision? \]                                                                         ↦r { { type: "ArrayLiteral", nodes:[...$$sym2, $sym4], pos } }

    <> element_list → elision? assignment_expression                                                            ↦r { [$sym1, $sym2 ] }
        │ elision? spread_element                                                                               ↦r { [ $sym1,$sym2 ] }
        │ element_list , elision? assignment_expression                                                         ↦r { [ ...$sym1, $sym3, $sym4 ] }
        │ element_list , elision? spread_element                                                                ↦r { [ ...$sym1, $sym3, $sym4 ] }

    <> elision → ,                                                                                              ↦r { { type: "Elision", count:0, pos } }
        │ elision ,                                                                                             ↦r { { type: "Elision", count:$sym1.count+1, pos } }

    <> spread_element → ... assignment_expression                                                               ↦r=>Spread

###############################################################################################################
#https://www.ecma-international.org/ecma-262/#prod-TemplateLiteral
###############################################################################################################

    <> template_literal → no_substitute_template
        │ substitute_template 

    <> no_substitute_template → ↦^parseTemplate ` `                                                             ↦r { { type: "Template", nodes:[ { quote_type:"", type: "StringLiteral", value:$sym1,  pos  } ], NO_SUBSTITUTE:true, pos } }

    <> substitute_template → template_head expression template_spans                                            ↦r { $sym3.unshift($sym1, $sym2), { type: "Template", nodes:$$sym3, pos } }

    <> template_spans → template_tail                                                                           ↦r { [ $sym1 ] }
        │ template_middle_list template_tail                                                                    ↦r { $sym1.push($sym2), $sym1 }           

    <> template_middle_list → template_middle expression                                                        ↦r { [ $sym1, $sym2 ] }
        │ template_middle_list template_middle expression                                                       ↦r { $sym1.push($sym2, $sym3), $sym1 }

    <> template_head →      ↦^parseTemplate  `  \${                                                             ↦r { { type:"TemplateHead", value:$sym1, pos  } }

    <> template_middle →    ↦^parseTemplate \}  \${                                                             ↦r { { type:"TemplateMiddle", value:$sym1,  pos  } }

    <> template_tail →      ↦^parseTemplate \}  `                                                               ↦r { { type:"TemplateTail", value:$sym1,  pos  } }

    <> template_characters → template_string_data (*")                                                          ↦r { { type: "StringLiteral", value:$sym1,  pos  } }
    
    <> template_string_data →  θnl │ θws │ θsym │ θop │ θcb │ θob │ θnum │ θid │ θany │ escaped_sequence                                      
                                                                                                              

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-language-lexical-grammar
###############################################################################################################

    <> literal → boolean_literal                
        │ null_literal
        │ string_literal                    
        │ numeric_literal
        │ bigint       

    <> string_literal → ↦^parseString \" \"                                                                     ↦r { { quote_type:$sym2, type: "StringLiteral", value:$$sym1 || "",  pos  } }
        │ ↦^parseString \' \'                                                                                   ↦r { { quote_type:$sym2, type: "StringLiteral", value:$$sym1 || "",  pos  } }

    <> string_data →   θnl │ θws │ θsym │ θop │ θcb │ θob │ θnum │ θid │ θany │ escaped_sequence                     #↦r { { type: "StringLiteral", value:$sym1,  pos  } }

    ##<> escaped_sequence → \\ ( ` │ ' │ " │ τb │ τf │ τn │ τr │ τy │ τv │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ hex_escape_sequence │ θany )   

    <> escaped_sequence → \\ (  θnl │ θws │ θsym │ θop │ θcb │ θob │ θnum │ θid │ θany )
                                                                                                                ↦r { $sym1 + $sym2}

    #<> hex_escape_sequence → τx θnum                                                                           ↦r { $sym1 + $sym2 + $sym3 }

    #<> unicode_escape_sequence → τu θnum                                                                       ↦r { $sym1 + $sym2 + $sym3 + $sym4 + $sym5 }
    #    │ τu \{ θnum \}                                                                                        ↦r { $sym1 + $sym2 + $sym3 + $sym4 }

    <> numeric_literal → -? θnum                                                                                ↦r { { type: "NumericLiteral", value:$sym1, computed_value:parseFloat($sym1), value_data:$sym1, pos, NEGATIVE:!!$$sym1 } }
    
    <> bigint →  -? θnum τn                                                                                     ↦r { { type: "BigIntLiteral", value:$sym2, pos, NEGATIVE:!!$$sym1 } }                                                        

    <> null_literal →  τnull                                                                                    ↦r { { type: "NullLiteral", pos  } }

    <> boolean_literal → τtrue                                                                                  ↦r { { type: "BooleanLiteral", value: $$sym1,  pos  } }
        │ τfalse                                                                                                ↦r { { type: "BooleanLiteral", value: $$sym1,  pos  } }

###############################################################################################################
# https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords
###############################################################################################################

    <> label_identifier → identifier                                                                            ↦r { $sym1.type = "IdentifierLabel", $sym1 }   
            #│ τyield                          
            #│ τawait                           

    <> identifier_reference → identifier                                                                        ↦r { $sym1.type = "IdentifierReference", $sym1 }
            #│ τyield                               
            #│ τawait                               

    <> binding_identifier → identifier                                                                          ↦r { $sym1.type = "IdentifierBinding", $sym1 }
            #│ τyield                               
            #│ τawait                               

    <> identifier → composite_identifier                                                                        ↦r { { type: "Identifier", value:$sym1,  pos  } }   
        │ unreserved_word                                                                                       ↦r { { type: "Identifier", value:$sym1,  pos  } }   

    <> identifier_name → composite_identifier                                                                    ↦r { { type: "IdentifierName", value:$sym1,  pos  } }              
        │ reserved_word                                                                                         ↦r { { type: "IdentifierName", value:$sym1,  pos  } } 
        │ unreserved_word                                                                                       ↦r { { type: "IdentifierName", value:$sym1,  pos  } }

    <> unreserved_word → τasync
        │ τget
        │ τset
        │ τtarget
        │ τas
        │ τfrom


    <> reserved_word →  keyword
        │ future_reserved_word
        │ τnull
        │ τtrue 
        │ τfalse                                                                                                               

    <> future_reserved_word → τimplements 
        │ τpackage 
        │ τprotected 
        │ τinterface
        │ τprivate
        │ τpublic

    <> composite_identifier > ↦^parseIdentifier θid                                                                             
        │ ↦^parseIdentifier \$  
        │ ↦^parseIdentifier \_  

    <> keyword → τawait
        │ τbreak
        │ τcase
        │ τcatch
        │ τclass
        │ τconst
        │ τcontinue
        │ τdebugger
        │ τdefault
        │ τdelete
        │ τdo
        │ τelse
        │ τexport
        │ τextends
        │ τfinally
        │ τfor
        │ τfunction
        │ τif
        │ τimport
        │ τin
        │ τinstanceof
        │ τnew
        │ τreturn
        │ τsuper
        │ τswitch
        │ τthis
        │ τthrow
        │ τtry
        │ τtypeof
        │ τvar
        │ τvoid
        │ τwhile
        │ τwith
        │ τyield
