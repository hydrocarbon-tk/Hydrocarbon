<h1 align=center>
    <img src="./flavor/cfw-flame-w-lib.svg" type="text/svg" rel="svg" height=80>
</h1>

<h3 align=center>A Recursive Descent Parser Compiler</h3>

<p align=center> <sub><b>v0.10.0</b></sub> </p>


CandleLibrary Hydrocarbon is a parser compiler that is able to create recusive descent parsers from a custom grammar format known as Hydrocarbon 
Grammars (.hcg). This format is inspired by the Backus-Naur Form syntax and is designed to be easy to use and expressive in the type of grammar 
constructs that can be defined. In addition, production reduce actions can specified in JavaScript to allow a generated parser to create 
**A**bstract **S**yntax **T**rees (AST), and also execute arbitrary code during parsing. 

Parsers generated by Hydrocarbon are in use within a majority of CandleLibrary packages (including Hydrocarbon itself), providing parsing 
facilities for full programming languages as in the case of Candle Library JS, Multi grammar parsing within Wick, and basic expression parsing
utilized by Paraffin's CLI argument parser.

# Usage

## Install

### Yarn
```bash
$ yarn global add @candlelib/hydrocarbon
```

### NPM
```bash
$ npm install -g @candlelib/hydrocarbon
```

> Note: Hydrocarbon uses the Emscripten compiler toolchain to build WebAssembly components. The current install script
> automatically pulls the latest version of Esmcripten from the EMSDK GitHub repository. Currently, the process only works
> on Linux & Unix like OS. Future work needs to be done to make this process work on MacOS and Windows based systems. An 
> alternative to downloading the emsdk library may also be implemented that will detected current emsdk installation and use 
> the existing emcc binary.

## Write A Grammar

```ini
# my_json_like_language.hcg
@IGNORE g:ws g:nl

<> JSON > object                                   

<> value > object
    | array
    | t:true                                        f:r{ true }
    | t:false                                       f:r{ false }
    | t:null                                        f:r{ null }
    | tk:number                                     f:r{ parseFloat($sym1) }
    | tk:string                                     f:r{ $sym1.slice(1,-1) }

<> object > \{  element(*\, )  \}                   f:r{ Object.fromEntries($$sym2 || [])  }

<> element > tk:string \: value                     f:r{ [$sym1.slice(1,-1), $sym3] }

<> array > \[ value(*\, ) \]                        f:r{ $$sym2 || [] }

<> number > g:num ( \. g:num )? ( \e g:num )?

<> string > \" ( g:id | g:num | g:sym )(*) \"

```

## Compile Parser
```bash
$ candle.hydrocarbon compile --threads 5 --recognizer wasm \./my_json_like_language.hcg
```


## Use the parser

```js
import json_parse from "./parser.js";

const { result } = json_parse('{"Hello World":[3, 1, 4, 1, 5, 9.265] }');

result[0]        // => { 'Hello World' : [3, 1, 4, 1, 5, 9.265]  }
typeof result[0] // => "object"

```

# CLI Usage

### ``candle.hydrocarbon compile <arguments?> <file path to .hcg>``

Compiles a parser from a Hydrocarbon grammar file

### Optional Arguments
| Argument | Value | Description |
|--|:--:|--|
| `--threads` |  `<number>`| Number of worker threads used to compiler parser. <br> Defaults to 1|
| `--output_dir` |  `<file path>`| Output directory for parser.<br> Defaults to the CWD|
| `--name` |  `<string>`| Name to give the parser file.<br> Defaults to 'parser'|
| `--recognizer_type` |  `<js \| wasm>`| Type of recognizer to create may either be `wasm` or `js`.<br> Defaults to `js`|
| `--annotations` | none | Add annotated comments to recognizer.<br> Only applicable when the recognizer is a `js` type.|


# Motivation

The primary reason this exists is to provide a flexible, easy to use parser compiler to handle the parsing demands of CandleLibrary packages such as Wick, JS, TS, Paraffin, and CSS. It provides a way of rapidly define new language syntax and is able combine grammars of different languages into one meta-parser.

# Grammar

## Symbols

### Defined Symbols 

Any terminal symbol that is defined using the forward slash `\` operator or otherwise is not a `production` non-terminal nor is operator of the Hydrocarbon grammar. Within this definition, Hydrocarbon further defines three separate  defined types:
- Defined Numeric:
    A discrete sequence of numerical characters within the ASCII range `0x30`to`0x39`, inclusive
    <br/> e.g: `\0123456 \321 \01110111` 

- Defined Identifier: 
    A discrete character sequence beginning with a Unicode character within the Unicode ID_Start character class. 
    <br/> e.g: `\symbol \function \01110111` 

- Defined Symbol: 
    Any character sequence that does not fall under the proceeding definitions.
    <br/> e.g: `\:warning:  \=NOT_VALID=   \===` 

### Generic Symbols

Hydrocarbon provides several "generated" terminal symbols that match a sequence of characters based on a preset pattern. There
are four generic symbols that can be used within a grammar definition:

- Generic Identifier: A sequence of characters starting with a character that belongs to the Unicode ID_Start class followed by any number of characters that belong to the Unicode ID_Continue class. 
    <br/> e.g: `g:id` 
- Generic Natural Number: Any number of characters within the ASCII range `0x30` to `0x39` . 
    <br/>RegEx definition: `[0-9]+`  e.g: `g:num` 
- Space: Any number of space characters, including ASCII code point `0x20` and characters belonging to the `WS` Unicode class. Also matches tab stop code points.
    <br/> e.g: `g:ws` 
- New Line: Any number of ASCII code points `0xA` and `0xF` to match `<LF>` and `<CRLF>`
  <br/> e.g: `g:nl` 
- Generic Symbol: Any SINGLE code point that does match one of the proceeding definitions for generic symbols
  <br/> e.g: `g:sym` 

### Production Token Symbols

A production can be treated as a single terminal symbol by prefixing the production name with`tk:`, such as `tk:function` for a production `<> function > ...`. 
By doing so, all characters that are recognized by the production will be combined into a character sequence string that serves
as the value of the production token symbol. 

## Operators

There a several operators that can be applied to symbols to direct the recognize to apply a particalure action on that symbol.

- *Optional*: `<symbol>?`

- *One or more*: `<symbol>(+)` 
    Instructs the parser to expect one or more iterations of the proceeding symbol within the input.

- *One or more as a string*: `<symbol>(+\' )`

- *Zero or more*: `<symbol>(*)`

    Instructs the recognizer to expect zero or more iterations of the proceeding symbol within the input.
    This operator can augmented to cause the recognizer to assert the presence of a delimiter between iterations, 
    > such as `g:sym(*\, )` which would match a string of symbols delimited by commas: `$,%,^,&,#`

- *One or more as a string*: `<symbol>(+\' )`

# Parser Design

The core functionality of a Hydrocarbon parser is split across two major parts, a **recognizer** and a **completer**. 

The **recognizer** performs the heavy lifting by parsing a binary input, identifying sequences of bytes that belong to productions of the grammar, and generating parse actions. There are four actions the recognizer can issue: `ACCEPT | SHIFT | REDUCE | SKIP`. These actions are encoded in 16bit integers and stored in an action buffer. 

The **completer** reads actions from the action buffer, and applies them to the binary input. It may also call user defined functions that accepts tokens generated by SHIFT actions. These functions may optionally return values that can be received by other custom functions. Both tokens, and values returned from the custom functions, get pushed to an output stack, which then returned by the **completer** once it finishes applying the parse actions. A primary use of the **completer** is to construct ASTs (Abstract Syntax Trees) from the text input, but it can be used for other tasks such as generating text highlighting or serving as a script interpreter.

The split functions allow the **recognizer** to be defined using C/C++ friendly syntax that is then compiled to a WASM module. The **completer** is written in TypeScrip/JavaScript. Future work will allow both the completer and the recognizer to be used in  languages other than TypeScript/JavaScript.

## ASCII, UTF-8, & byte parsing

## Tokenizer-less Parsing

## Unlimited Look Ahead

## Left Recursion

A imitation of standard recursive descent parsers is their inability to parse production that have a left recursion.
as in `P =: P a | P =: b`, in which case the function responsible for the production `P` would be recursively called while trying to match the production body `P a`, leading to an infinite loop and potentially a stack overflow. The traditional fix for this problem is to rewrite the grammar
of the production to remove the left recursion; for example production `P` is rewritten to
```bnf
P   =: Pf a
Pf  =: b P
     | b  
```
which remove the left recursion and makes the grammar recursive descent friendly.

Hydrocarbon's parser design overcomes this limitation and directly supports left recursion, allowing grammars to be written in forms that are easy to understand. Furthermore, left recursion results in less resource overhead, allowing parsers to use code loops instead of creating new function frames during the parsing of recursive inputs. This means left recursion is the preferred method of describing recursive productions.


# Grammar Todo
- Look for mistakes and automatically remove them or warn about them
    - duplicate productions bodies
    - Unmatched sentinels

# Road-Map
## Version 1 Feature set

- [*] Grammer for creating parsers 
- [*] Compile parser for use TypeScript/Javascript with Web Assembly Recognizer
- [*] Production Selection to parse individual productions instead of the goal production
- [*] TypeScript Definitions for parser, recognizer & environment
- [*] Revisions to Grammer
- Documentation for the above features.

## Version 2 Feature set
- Streaming Parsing & Restartable recognition 
- Parallel Parsing - Allow blocks to be parsed concurrently
- Automatic AST generating 
- Online Demonstration 
- Syntax Highlighting Plugin
- Support for other grammar file types.

## Version 3 Feature set
- Rewrite parser compiler in a compiled language
- Make parser front end for other languages

# Contribution

If you have any problems using hydrocarbon, or would like to suggest a new feature, please open an [issue](https://github.com/CandleLibrary/hydrocarbon/issues).

If you would like to contribute to the development of hydrocarbon, fork the repository, create and develop on a new branch, and create a pull request from your forked repo.

# License

Licensed under the GNU General Public License version 3

[GNU GPL v3](./LICENSE)

